\begin{sloppypar} % помогает в кириллическом документе выровнять текст по краям
\newpage % Так добавляется  новая страница
\section{РАЗРАБОТКА ПРОГРАММЫ} %Объявили начало раздела
\subsection{Разработка алгоритма}
Сначала нужно понять, что необходимо для выполнения задач, поставленных в задании. Нужно проиницилизировать необходимую переферию и настроить их в нужный режим работы, для чего нужно тщательно изучить даташиты на все компоненты.

Требуется обновлять данные с частотой 400Гц --  для этого нужен таймер. Нужно каким-то образом обрабатывать полученные данные и отсылать результат по Bluetooth. 

Для работы программы необходимо для начала разработать алгоритм. Алгоритм нашего устройства представлен на рисунке \ref{ris:prog/algo.png}.
\imghh{150mm}{prog/algo.png}{Алгоритм работы устройства}


Главное тело программы работает так -  инициализирует всю необходимую переферию микроконтроллера, после чего проверяет launch\_flg - флаг, который поднимается в прерывании от таймера каждые 2.5мс, что соответствует частоте обновления данных в 400Гц. 


Так же есть три прерывания -- по переполнению счетчика таймера, и два внешних - по изменению уровня на выводах акселерометра INT0 INT1, подключенных к выводам микроконтроллера PA4 и PA5.


Если флаг запуска  launch\_flg==true, то ждем, когда установится флаг data\_flg(который устанавливается по готовности данных в акселерометре). После этого проверяем флаг свободного падения free\_fall\_flg==true. Если он активен - то помимо данных об ускорении пишем еще и сообщение о том, что произошло падение. Если free\_fall\_flg==false, то просто передаем данные по ускорению. Таким образом, для определения характера движения была использована гибкая система прерываний ADXL345. Подробнее о ней в следующем разделе.

\subsection{Разработка кода}

\subsubsection{Выбор программного обеспечения}
Для разработки ПО под STM32 можно использовать различные IDE. Самые популярные — IAR, Keil, Coocox (Eclipse). Мы же пойдем по пути, который с недавних пор абсолютно бесплатно и в полном объеме предоставляет сама ST.


STM32CubeIDE – многофункциональное средство разработки, являющееся частью экосистемы STM32Cube от компании STMicroelectronics.
STM32CubeIDE – платформа разработки C/C++ с IP-конфигурацией, генерацией и компиляцией кода и способностью прошивки микроконтроллеров STM32.
Программное обеспечение построено на платформе ECLIPSE™/CDT и пакетов программ GCC для разработки, а также отладчика GDB для прошивки микроконтроллера.


Какие плюсы у данного ПО: абсолютно бесплатно, нет ограничения по размеру кода, есть неплохой отладчик, простая установка и настройка. Так же, стоит отметить, что данная платформа кроссплатформенная - есть версии для Windows, Linux и даже MacOS. Ознакомиться с STM32CubeIDE можно в \cite{STM32CubeIDE}

\subsubsection{Инициализация переферии}
В STM32CubeIDE встроен STM32CubeMx -- программный продукт, позволяющий легко и непринужденно при помощи достаточно понятного графического интерфейса произвести настройку любой имеющейся на борту микроконтроллера периферии. 

Предыстория создания CubeMx такова - ST имеют очень разнообразную линейку микроконтроллеров, тут и Cortex-M0, и Cortex-M0+, и Cortex-M3, и Cortex-M4. Соответственно, встает вопрос о каком-то едином наборе библиотек и едином инструменте для инициализации и конфигурирования всего этого многообразия. Вот для решения этих целей и был выпущен STM32CubeMx.

Суть концепции такова - создаем проект, выбираем микроконтроллер, и нам сразу же предлагается схема со всеми выводами выбранного контроллера. Нажимая на выводы и заходя в разнообразные меню, мы легко настраиваем как периферию, так и режимы работы каждого конкретного вывода. Сразу же очевидные плюсы - можно наглядно увидеть, какие выводы уже заняты, а какие еще свободны (в крупных проектах - более чем полезная функция).
Подробнее об этом можно прочитать в \cite{cube}

В нашем случае нужно создать проект, выбрать микроконтроллер и подключить переферию - таймер, $I^2$C, тактирование. Все это настраивается в графическом интерфейсе.

 Сначала в настройках Reset and Clock Controller(RCC) подключаем кварцевые резонаторы, как показано на рисунке \ref{ris:cub/rcc.png}.
\imghh{150mm}{cub/rcc.png}{Настройки RCC}

Затем подключим интерфейс $I^2$C, как показано на рисунке \ref{ris:cub/i2c.png}.
\imghh{150mm}{cub/i2c.png}{Настройки $I^2$C}

Затем подключим порты ввода-вывода и настроим их как внешний источник прерываний, как показано на рисунке \ref{ris:cub/gpio.png}.
\imghh{150mm}{cub/gpio.png}{Настройки портов ввода-вывода}

После этого можно настроить тактирование на вкладке Clock Configuration, как показано на рисунке \ref{ris:cub/clock.png}.
\imghh{150mm}{cub/clock.png}{Настройки тактирования}

Для включения стека Bluetooth необходимо активировать Inter-Process Communication Controller(IPCCC), Hardware Semaphore (HSEM) (необходим для синхронизации процессов, запущеных на разных ядрах), как показано на рисунках  \ref{ris:cub/IPCC.png}, \ref{ris:cub/HSEM.png}, включить Radio System(RF),как показано на рисунке \ref{ris:cub/RF.png}.

\imghh{150mm}{cub/IPCC.png}{Активируем IPCC}
\imghh{150mm}{cub/HSEM.png}{Активируем HSEM}
\imghh{150mm}{cub/RF.png}{Активируем RF}
Теперь разблокирована вкладка STM32WPAN, где нужно включить стек Bluetooth. В настройках указываем, что конечное устройство будет являться сервером(то есть транслировать данные другим устройствам). Настройки показаны на рисунке \ref{ris:cub/BLE.png}.
\imghh{150mm}{cub/BLE.png}{Активируем Bluetooth}


























\subsubsection{Инициализация ADXL345}
 Карта регистров представлена на рисунке \ref{ris:prog/adxl_regmap.png}.
\imghh{150mm}{prog/adxl_regmap.png}{Описания регистров и их адреса}

Для удобства перенесем эту карту в код: 
\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
% linenos%нумерация строк
]{C}
#define DEVID_ID			0x00
#define THRESH_TAP			0x1D
#define OFSX 			    0x1E
#define OFSY 				0x0F
#define OFSZ 				0x20
#define DUR 				0x21
#define Latent 				0x22
#define Window 				0x23
#define THRESH_ACT			0x24
#define THRESH_INACT		0x25
#define TIME_INACT			0x26
#define ACT_INACT_CTL		0x27
#define THRESH_FF			0x28
#define TIME_FF 			0x29
#define TAP_AXES			0x2A
#define ACT_TAP_STATUS		0x2B
#define BW_RATE 			0x2C
#define POWER_CTL			0x2D
#define INT_ENABLE			0x2E
#define INT_MAP 			0x2F
#define INT_SOURCE			0x30
#define DATA_FORMAT			0x31
#define DATAX0   			0x32
#define DATAX1   			0x33
#define DATAY0   			0x34
#define DATAY1   			0x35
#define DATAZ0   			0x36
#define DATAZ1   			0x37
#define FIFO_CTL  			0x38
#define FIFO_STATUS  		0x39
\end{minted}

Далее необходимо эти регистры проинициализировать.
Связь с акселерометром происходит по $I^2$C. Значит, перед тем как передать настройки регистров, нужно сформировать необходимый пакет и отправить его на шину $I^2$C.  Для этого объявлена функция adxl\_write.


\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
% linenos%нумерация строк
]{C}
void adxl_write(uint8_t address_reg, uint8_t value) {//запись в регистр
	uint8_t data[2];//массив для хранения посылки
	data[0] = address_reg;//cначала передаем адрес регистра в который будем читать
	data[1] = value; //Затем значение которое нужно записываем
	HAL_I2C_Master_Transmit(&hi2c1, adxl_addr, data, 2, timeout)  ;//отправляем массив с адресом и значением
}

\end{minted}


Так же для инициализации объявлена функция adxl\_init.

\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}
void adxl_init(void) {//инициализация акселерометра и настройка

	adxl_write(DATA_FORMAT, RANGE_8G);  //настраиваем диапазон +- 8g

	adxl_write(POWER_CTL, 0x00);  // выход из режима сна
	adxl_write(POWER_CTL, 0x08);  //включаем преобразование
	
	adxl_write(THRESH_FF, 0x06);  //настраиваем значение free fall treshold = 62.5mg*8=0.5g
	adxl_write(TIME_FF, 0x02);     //настраиваем время free fall
	//по двум параметрам выше срабатывает прерывание

	adxl_write(INT_ENABLE, FREE_FALL);     //включаем прерывание от free fall
	adxl_write(INT_MAP, FREE_FALL);  //назначаем его на вывод IN1

	adxl_write(INT_ENABLE, DATA_READY); //включаем прерывание по готовности данных
	adxl_write(INT_MAP, DATA_READY);  //назначаем его на вывод IN0

}

\end{minted}

Разберем строки подробнее.

\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}
void adxl_init(void) {//инициализация акселерометра и настройка

	adxl_write(DATA_FORMAT, RANGE_8G);  //настраиваем диапазон +- 8g
}
\end{minted}


Эта строка записывает в регистр DATA\_FORMAT значение, соотвествующее диапазону +-8g. Возможные диапазоны были так же предварительно объявлены. 


\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 linenos%нумерация строк
]{C}
void adxl_init(void) {
//инициализация акселерометра и настройка
#define RANGE_2G		0x00
#define RANGE_4G		0x01
#define RANGE_8G		0x02
#define RANGE_16G		0x03
}
\end{minted}
 
Здесь и далее вся информация из \cite{ADXL}, на рисунках \ref{ris:prog/range.png} и \ref{ris:prog/range1.png} представлены необходимые фрагменты.
\imghh{70mm}{prog/range.png}{Описаниe регистра }
\imghh{70mm}{prog/range1.png}{Возможные значения для настройки}


\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}

	adxl_write(POWER_CTL, 0x00);  // выход из режима сна
	adxl_write(POWER_CTL, 0x08);  //включаем преобразование

\end{minted}

Данные две строчки сначала очищают регистр POWER\_CTL, затем инициализируют включение режима преобразования. Регистр показан на рисунке \ref{ris:prog/pwrctl.png} 
\imghh{70mm}{prog/pwrctl.png}{регистр POWER\_CTL}


\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}

	adxl_write(THRESH_FF, 0x06);  //настраиваем значение free fall treshold = 62.5mg*8=0.5g
	adxl_write(TIME_FF, 0x14);     //настраиваем время free fall =5ms*30=150ms
	//по двум параметрам выше срабатывает прерывание
\end{minted}

Данные две строчки записывают значения в регистры THRESH\_FF  и TIME\_FF  значения ускорения и времени, необходимых для того чтобы сработало прерывание по свободному падению. На рисунке \ref{ris:prog/tresh.png} показано описание регистров.
\imghh{70mm}{prog/tresh.png}{Описаниe регистров THRESH\_FF  и TIME\_FF }



\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}


	adxl_write(INT_ENABLE, FREE_FALL);     //включаем прерывание от free fall
	adxl_write(INT_MAP, FREE_FALL);  //назначаем его на вывод IN1

	adxl_write(INT_ENABLE, DATA_READY); //включаем прерывание по готовности данных
	adxl_write(INT_MAP, DATA_READY);  //назначаем его на вывод IN0

\end{minted}

Эти строки включают прерывания  по свободному падению и готовности данных и назначают их на соотвествующие выводы. Возможные для настройки прерывания показан на рисунке \ref{ris:prog/interrupt.png}, про активацию необходимых прерываний и настройку выводов показано на рисунке \ref{ris:prog/interrupt_map.png}
 \imghh{150mm}{prog/interrupt.png}{Возможные прерывания}
 \imghh{70mm}{prog/interrupt_map.png}{Настройка прерываний}
 
 
 На этом инициализацию устройства можно считать законченной.
 
 Так же объявляется функция adxl\_read для чтения данных с регистров акселерометра.
 
 \begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C++}
uint8_t adxl_read(uint8_t address_reg) {//чтение с регистра одного байта
	address_reg |= 0x80;  // маска для задания бита чтения
	uint8_t data[1]={0}; //переменная для прочитанных данных

	HAL_I2C_Master_Transmit(&hi2c1, adxl_addr, address_reg, 1, timeout);
	//посылаем адрес регистра, с которого хотим читать

	HAL_I2C_Master_Receive(&hi2c1, adxl_addr, data, 1, timeout);
	//читаем байт в переменную data
	return data;
}

\end{minted}
 
 
 
Данный фрагмент сначала формирует адрес и по маске устанавливает бит, отвечающий за чтение, согласно интерфейсу $I^2$C. Затем объявляется переменная для хранения данных. 

 \begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C++}
HAL_I2C_Master_Transmit(&hi2c1, adxl_addr, address_reg, 1, timeout);
\end{minted}
 передает на шину $I^2$C адрес устройства с которым хочет связаться в формате чтения, и передает один байт, в котором содержится адрес регистра.
 
 Далее функция
    \begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C++}
   HAL_I2C_Master_Receive(&hi2c1, adxl_addr, data, 1, timeout);
\end{minted}
запрашивает у устройства один байт данных, и записывает его в переменную, которую функция потом вернет.




\end{sloppypar}
