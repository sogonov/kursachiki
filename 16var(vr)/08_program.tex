\begin{sloppypar} % помогает в кириллическом документе выровнять текст по краям
\newpage % Так добавляется  новая страница
\section{РАЗРАБОТКА ПРОГРАММЫ} %Объявили начало раздела
\subsection{Разработка алгоритма}

Проанализируем задание, учитывая ранее описанное. Необходимо получать данные от \ac{AFE} микросхемы ADS1293 по интерфейсу SPI, записывать их во флеш-память W25Q128. Так же данные передаются по интерфейсу Bluetooth.


Для работы программы необходимо для начала разработать алгоритм. Алгоритм нашего устройства представлен на рисунке \ref{prog/algo.png}.
\imghh{150mm}{prog/algo.png}{Алгоритм работы устройства}


% Главное тело программы работает так -  инициализирует всю необходимую переферию микроконтроллера, после чего проверяет launch\_flg - флаг, который поднимается в прерывании от таймера каждые 2.5мс, что соответствует частоте обновления данных в 400Гц. 


% Так же есть три прерывания -- по переполнению счетчика таймера, и два внешних - по изменению уровня на выводах акселерометра INT0 INT1, подключенных к выводам микроконтроллера PA4 и PA5.


% Если флаг запуска  launch\_flg==true, то ждем, когда установится флаг data\_flg(который устанавливается по готовности данных в акселерометре). После этого проверяем флаг свободного падения free\_fall\_flg==true. Если он активен - то помимо данных об ускорении пишем еще и сообщение о том, что произошло падение. Если free\_fall\_flg==false, то просто передаем данные по ускорению. Таким образом, для определения характера движения была использована гибкая система прерываний ADXL345. Подробнее о ней в следующем разделе.




\subsection{Разработка кода}

\subsubsection{Выбор программного обеспечения}
Для разработки ПО под STM32 можно использовать различные IDE. Самые популярные — IAR, Keil, Coocox (Eclipse). Мы же пойдем по пути, который с недавних пор абсолютно бесплатно и в полном объеме предоставляет сама ST.


STM32CubeIDE – многофункциональное средство разработки, являющееся частью экосистемы STM32Cube от компании STMicroelectronics.
STM32CubeIDE – платформа разработки C/C++ с IP-конфигурацией, генерацией и компиляцией кода и способностью прошивки микроконтроллеров STM32.
Программное обеспечение построено на платформе ECLIPSE™/CDT и пакетов программ GCC для разработки, а также отладчика GDB для прошивки микроконтроллера.


Какие плюсы у данного ПО: абсолютно бесплатно, нет ограничения по размеру кода, есть неплохой отладчик, простая установка и настройка. Так же, стоит отметить, что данная платформа кроссплатформенная - есть версии для Windows, Linux и даже MacOS. Ознакомиться с STM32CubeIDE можно в \cite{STM32CubeIDE}

\subsubsection{Инициализация периферии}
В STM32CubeIDE встроен STM32CubeMx -- программный продукт, позволяющий при помощи достаточно понятного графического интерфейса произвести настройку любой имеющейся на борту микроконтроллера периферии. Подробнее об этом можно прочитать в \cite{cube}

В нашем случае нужно создать проект, выбрать микроконтроллер и подключить периферию - таймер, SPI, тактирование. Все это настраивается в графическом интерфейсе.

Сначала в настройках Reset and Clock Controller(RCC) подключаем кварцевые резонаторы, как показано на рисунке \ref{ris:cub/rcc.png}.
\imghh{150mm}{cub/rcc.png}{Настройки RCC}

Затем подключим порты ввода-вывода и настроим их как внешний источник прерываний, как показано на рисунке \ref{ris:cub/gpio.png}.
\imghh{150mm}{cub/gpio.png}{Настройки портов ввода-вывода}

Затем подключим порты ввода-вывода и настроим их как внешний источник прерываний, как показано на рисунке \ref{ris:cub/spi.png}.
\imghh{150mm}{cub/spi.png}{Настройки портов ввода-вывода}

После этого можно настроить тактирование на вкладке Clock Configuration, как показано на рисунке \ref{ris:cub/clock.png}.
\imghh{150mm}{cub/clock.png}{Настройки тактирования}

Так же включаем таймер - он необходим для того, чтобы 


Для включения стека Bluetooth необходимо активировать Inter-Process Communication Controller(IPCCC), Hardware Semaphore (HSEM) (необходим для синхронизации процессов, запущеных на разных ядрах), как показано на рисунках  \ref{ris:cub/IPCC.png}, \ref{ris:cub/HSEM.png}, включить Radio System(RF),как показано на рисунке \ref{ris:cub/RF.png}.

\imghh{150mm}{cub/IPCC.png}{Активируем IPCC}
\imghh{150mm}{cub/HSEM.png}{Активируем HSEM}
\imghh{150mm}{cub/RF.png}{Активируем RF}
Теперь разблокирована вкладка STM32WPAN, где нужно включить стек Bluetooth. В настройках указываем, что конечное устройство будет являться сервером(то есть транслировать данные другим устройствам). Настройки показаны на рисунке \ref{ris:cub/BLE.png}.
\imghh{150mm}{cub/BLE.png}{Активируем Bluetooth}

Дальше все настройки будут происходить в коде. После активации стека Bluetooth в директории проекта появляется множество файлов, отвечающих за функции радиоядра и сервисы Bluetooth.

Стоит отметить, что в данной линейке микропроцессоров используется еще не полноценная операционная система реального времени, но уже вполне функциональный диспетчер задач - Sequensor.

Для запуска этого диспетчера надо добавить строку в файл main.с вызов диспетчера задач(UTIL\_SEQ\_Run), а так же подключить библиотеки, содержащие все необходимые функции.


\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}

/* USER CODE BEGIN Includes */
#include "stm32_seq.h"  //подключаем  библиотеку Sequensor
/* USER CODE END Includes */


/* USER CODE BEGIN PV */
uint8_t send_ble[2] = {0,0};
/* USER CODE END PV */

/* USER CODE BEGIN WHILE */
while (1)
{
   UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);  //запускаем  его в стандартном режиме.
   
/* USER CODE END WHILE */
}
\end{minted}

Активируем прерывания от Inter-Process Communication Controller


\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк
]{C}
/* USER CODE BEGIN 1 */
void RTC_WKUP_IRQHandler(void)
{
  HW_TS_RTC_Wakeup_Handler();
}

void IPCC_C1_TX_IRQHandler(void)
{
  HW_IPCC_Tx_Handler();

  return;
}

void IPCC_C1_RX_IRQHandler(void)
{
  HW_IPCC_Rx_Handler();
  return;
}
/* USER CODE END 1 */


\end{minted}




В  файле app\_ble.c уже автоматически прописано соединение клиента с сервером, описаны оснновные функции инициализации и настроек. Можно изменить этот файл, добавив свой функционал. Добавим простое включение и выключение светодиода при активной передаче данных. Файл генерируется большой, в приложении не приводим, отметим лишь то место, куда добавляем собственный код. Светодиод так же подключаем с помощью графического интерфейса, и присваиваем ему метку LED\_Pin, а порту присваиваем LED\_GPIO\_Pin. 

\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк3
]{C}
/* USER CODE BEGIN RADIO_ACTIVITY_EVENT*/
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET); // включение светодиода
HAL_Delay(5); //небольшая задержка
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET); //отключение светодиода
/* USER CODE END RADIO_ACTIVITY_EVENT*/

\end{minted}








В  файле p2p\_server\_app.c описаны функции, занимающиеся именно протоколом Bluetooth. Так же можно изменить этот файл, добавив свой функционал. 
\begin{minted} [
% frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
 % bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
 % linenos%нумерация строк3
]{C}

/* USER CODE BEGIN PTD */
unsigned char inputMessage = 0; //локальная переменная
uint8_t local[2] = {0,0};//массив для передачи
/* USER CODE END PTD */

/* USER CODE BEGIN PD */
void P2PS_Send_Notification(void);//прототип функции, отправляющей данные по Bluetooth
/* USER CODE END PD */

/* USER CODE BEGIN P2PS_STM_WRITE_EVT */
inputMessage = pNotification->DataTransfered.pPayload[1]; //присваиваем переременной значение из элемента структуры DataTransfered
/* USER CODE END P2PS_STM_WRITE_EVT */
g
/* USER CODE BEGIN FD_LOCAL_FUNCTIONS*/
void P2PS_Send_Notification(void) 
{
// формируем посылку
local[1] = send_ble[0];
local[0] = 1;
P2PS_STM_App_Update_Char(P2P_NOTIFY_CHAR_UUID, (uint8_t *)(&local));//отправляем данные по Bluetooth.
}
/* USER CODE END FD_LOCAL_FUNCTIONS*/

/* USER CODE BEGIN P2PS_APP_Init */
UTIL_SEQ_RegTask( 1<< CFG_TASK_RECEIVE_UART_ID, UTIL_SEQ_RFU, P2PS_Send_Notification);
/* USER CODE END P2PS_APP_Init */

\end{minted}

















\end{sloppypar}
